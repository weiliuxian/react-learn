# 组件状态
组件状态：组件可以自行维护的数据，仅在类组件中有效；
状态（state）：本质上是类组件的一个属性，是一个对象

**状态初始化**
有两种初始化方式
 this.state = {
    left: this.props.number
 }

**状态的变化**
不能直接改变状态：因为react无法监控到状态发生了变化
必须使用this.setState({})改变状态
一旦调用了this.setState(),会导致组件重新渲染


**组件中的数据**
1、props：该数据是由组件的使用者传递的数据，所有权不属于组件自身，因此组件无法该数据
2、state：该数据是组件自身创建，所有权属于自身，因此该组件有权改变该数据


# 深入认识setState

setState，对状态的改变可能是异步的，只有状态改变了才会触发render函数，
> 如果改变状态的代码处于某个HTML元素的事件中，则其是异步的，否则是同步的，为了避免出错，以后都把setState当成异步处理，因此可以在setState的第二参数回调函数里面获得更新后的状态

如果遇到某个事件中，需要同步调用多次，需要使用函数的方式得到最新状态

this.setState(cur => {
   // 参数cur表示当前的状态
   // 该函数返回结果，会混合（覆盖）之前的状态
   // 该函数是异步执行
   return {
         n: cur.n + 1
   }
}, () => {
   // 所有的异步更新状态完成后执行
   console.log('state更新完成')
})

最佳实践：
1. 把所有的setState当作异步
2. 永远不要信任setState调用之后的状态
3. 如果要使用改变后的状态，需要使用回调函数（setState的第二个参数）
4. 如果新的状态要根据之前的状态进行运算，使用函数的方式改变状态（setState的第一个参数（函数））

React会对异步的setState进行优化，将多次setState进行合并（将多次状态改变完成后，再统一对setState进行改变，然后触发render函数）


# 生命周期

**生命周期仅存在于类组件中，函数组件每次调用都是重新运行，旧的组件即可被销毁**

## 旧版生命周期
React < 16.0.0
1. constructor： 初始化
   1. 同一个组件对象只会创建一次
   2. 不能在第一次挂载之前调用setState，为了避免问题，构造函数中不能调用setState

2. componentWillMount：组件即将被挂载
   1. 正常情况下，和构造函数一样，只会运行一次
   2. 可以使用setState，但是为了避免bug，不允许使用，因为在某些特殊情况下，该函数可能被调用多次
   
3. **render**： 
   1. 返回一个虚拟dom，会被挂载到虚拟dom树中，最终渲染到页面的真实dom中
   2. render可能不只运行一次，只要需要重新渲染，就会重新运行
   3. 严禁使用setState，因为会导致无限递归渲染

4. **componentDidMount**: 挂载完成
   1. 只会执行一次
   2. 可以使用setState
   3. 通常情况下，会将网络请求、启动计时器等一开始需要的操作，书写到该函数中

5. 组件进入活跃状态

6. componentWillReceiveProps:
   1. 即将接受新的属性值
   2. 参数为新的属性对象
   3. 该函数可能会导致一些bug，不推荐使用

7. **shouldComponentUpdate**:
   1. 指示React是否要重新渲染该组件，通过返回true和false来指定
   2. 默认情况下，会直接返回true

8. componentWillUpdate
   1. 组件即将被重新渲染

9. render

10. componentDidUpdate
   1. 往往在该函数中使用dom操作，改变元素

11. **componentWillUnmount**
   1. 通常在该函数中销毁一些组件依赖的资源，比如计时器

## 新版生命周期
React >= 16.0.0

1. getDeriveStateFromProps
   1. 通过参数可以获取新的属性和状态
   2. 该函数是静态的
   3. 该函数的返回值会覆盖掉组件状态
   4. 该函数几乎没什么用
2. getSnapshotBeforeUpdate
   1. 虚拟DOM树构建完成，但是还未实际渲染到页面中
   2. 在该函数中，通常用于实现一些附加的dom操作
   3. 该函数的返回值会作为componentDidUpdate的第三个参数

# 传递元素内容

如果给自定义组件传递元素内容，则react会将元素内容作为children属性传递过去



# 属性默认值
通过一个静态属性```defaultProps```告知react属性默认值

FuncDefault函数组件：如果父组件传递了对应的属性值，则会自动进行混合，在构造函数内部获取的props是混合之后的
```
FuncDefault.defaultProps = {
   a: 1,
   b: 2
}
```

FuncDefault类组件： 如果父组件传递了对应的属性值，则会自动进行混合，调用的constructor时也是混合之后的
```
FuncDefault.defaultProps = {
   a: 1,
   b: 2
}  或者

static defaultProps = {
   a: 1,
   b: 2
}

constructor(props){
   super(props)
}
```

# 属性类型检查

使用第库： ```props-types```
对组件使用静态属性```propTypes```告知react如何检查属性

```
 PropTypes.any   1、可以设置必填  2、列出所有属性（不明确类的属性也列出来，可以看到完整属性）
 PropTypes.number
 PropTypes.bool
 PropTypes.func
 PropTypes.object
 PropTypes.string
 PropTypes.symbol

 PropTypes.node  // 任何可以被渲染的东西（字符串、数字、react元素,如果是null和undefined，没有非空验证时默认是空）
 PropTypes.element  //react元素 
 PropTypes.elementType  //react组件类型
 PropTypes.instanceOf(构造函数)  //必须是指定构造函数的实例
 PropTypes.oneOf([xxx,xxx])  //枚举
 PropTypes.oneOfType([xxx,xxx])  //属性类型必须是数组中的一个
 PropTypes.arrayOf(PropTypes.xxx)  //必须是某一类型组成的数组
 PropTypes.objectOf(PropTypes.xxx)  //对象由某一类型的值组成
 PropTypes.shape(对象)  //属性必须是对象，并且满足指定的对象要求

 PropTypes.exact({...})  //对象必须精确匹配传递的数据(不能有多余的属性，用法和shape一样)

 属性： function(props,propName,componentName){
    // ...
 }

```


# HOC（Higher-Order Function） 高阶组件

HOF： 高阶函数，以函数作为参数，并返回一个函数

通常，可以利用HOC实现横切关注点

举例： 20个组件，每个组件在创建组件和销毁组件时，需要作日志记录
20个组件，他们需要显示一些内容，得到的数据结构完全一致

**注意**
1. 不要在render里面使用高阶函数
2. 不要在高阶组件内部更改传入的组件