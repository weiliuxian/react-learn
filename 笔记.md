
# 组件状态
组件状态：组件可以自行维护的数据，仅在类组件中有效；
状态（state）：本质上是类组件的一个属性，是一个对象

**状态初始化**
有两种初始化方式
 this.state = {
    left: this.props.number
 }

**状态的变化**
不能直接改变状态：因为react无法监控到状态发生了变化
必须使用this.setState({})改变状态
一旦调用了this.setState(),会导致组件重新渲染


**组件中的数据**
1、props：该数据是由组件的使用者传递的数据，所有权不属于组件自身，因此组件无法该数据
2、state：该数据是组件自身创建，所有权属于自身，因此该组件有权改变该数据


# 深入认识setState

setState，对状态的改变可能是异步的，只有状态改变了才会触发render函数，
> 如果改变状态的代码处于某个HTML元素的事件中，则其是异步的，否则是同步的，为了避免出错，以后都把setState当成异步处理，因此可以在setState的第二参数回调函数里面获得更新后的状态

如果遇到某个事件中，需要同步调用多次，需要使用函数的方式得到最新状态

this.setState(cur => {
   // 参数cur表示当前的状态
   // 该函数返回结果，会混合（覆盖）之前的状态
   // 该函数是异步执行
   return {
         n: cur.n + 1
   }
}, () => {
   // 所有的异步更新状态完成后执行
   console.log('state更新完成')
})

最佳实践：
1. 把所有的setState当作异步
2. 永远不要信任setState调用之后的状态
3. 如果要使用改变后的状态，需要使用回调函数（setState的第二个参数）
4. 如果新的状态要根据之前的状态进行运算，使用函数的方式改变状态（setState的第一个参数（函数））

React会对异步的setState进行优化，将多次setState进行合并（将多次状态改变完成后，再统一对setState进行改变，然后触发render函数）


# 生命周期

**生命周期仅存在于类组件中，函数组件每次调用都是重新运行，旧的组件即可被销毁**

## 旧版生命周期
React < 16.0.0
1. constructor： 初始化
   1. 同一个组件对象只会创建一次
   2. 不能在第一次挂载之前调用setState，为了避免问题，构造函数中不能调用setState

2. componentWillMount：组件即将被挂载
   1. 正常情况下，和构造函数一样，只会运行一次
   2. 可以使用setState，但是为了避免bug，不允许使用，因为在某些特殊情况下，该函数可能被调用多次
   
3. **render**： 
   1. 返回一个虚拟dom，会被挂载到虚拟dom树中，最终渲染到页面的真实dom中
   2. render可能不只运行一次，只要需要重新渲染，就会重新运行
   3. 严禁使用setState，因为会导致无限递归渲染

4. **componentDidMount**: 挂载完成
   1. 只会执行一次
   2. 可以使用setState
   3. 通常情况下，会将网络请求、启动计时器等一开始需要的操作，书写到该函数中

5. 组件进入活跃状态

6. componentWillReceiveProps:
   1. 即将接受新的属性值
   2. 参数为新的属性对象
   3. 该函数可能会导致一些bug，不推荐使用

7. **shouldComponentUpdate**:
   1. 指示React是否要重新渲染该组件，通过返回true和false来指定
   2. 默认情况下，会直接返回true

8. componentWillUpdate
   1. 组件即将被重新渲染

9. render

10. componentDidUpdate
   1. 往往在该函数中使用dom操作，改变元素

11. **componentWillUnmount**
   1. 通常在该函数中销毁一些组件依赖的资源，比如计时器

## 新版生命周期
React >= 16.0.0

1. getDeriveStateFromProps
   1. 通过参数可以获取新的属性和状态
   2. 该函数是静态的
   3. 该函数的返回值会覆盖掉组件状态
   4. 该函数几乎没什么用
2. getSnapshotBeforeUpdate
   1. 虚拟DOM树构建完成，但是还未实际渲染到页面中
   2. 在该函数中，通常用于实现一些附加的dom操作
   3. 该函数的返回值会作为componentDidUpdate的第三个参数

# 传递元素内容

如果给自定义组件传递元素内容，则react会将元素内容作为children属性传递过去



# 属性默认值
通过一个静态属性```defaultProps```告知react属性默认值

FuncDefault函数组件：如果父组件传递了对应的属性值，则会自动进行混合，在构造函数内部获取的props是混合之后的
```
FuncDefault.defaultProps = {
   a: 1,
   b: 2
}
```

FuncDefault类组件： 如果父组件传递了对应的属性值，则会自动进行混合，调用的constructor时也是混合之后的
```
FuncDefault.defaultProps = {
   a: 1,
   b: 2
}  或者

static defaultProps = {
   a: 1,
   b: 2
}

constructor(props){
   super(props)
}
```

# 属性类型检查

使用库： ```props-types```
对组件使用静态属性```propTypes```告知react如何检查属性

```
 PropTypes.any   1、可以设置必填  2、列出所有属性（不明确类的属性也列出来，可以看到完整属性）
 PropTypes.number
 PropTypes.bool
 PropTypes.func
 PropTypes.object
 PropTypes.string
 PropTypes.symbol

 PropTypes.node  // 任何可以被渲染的东西（字符串、数字、react元素,如果是null和undefined，没有非空验证时默认是空）
 PropTypes.element  //react元素 
 PropTypes.elementType  //react组件类型
 PropTypes.instanceOf(构造函数)  //必须是指定构造函数的实例
 PropTypes.oneOf([xxx,xxx])  //枚举
 PropTypes.oneOfType([xxx,xxx])  //属性类型必须是数组中的一个
 PropTypes.arrayOf(PropTypes.xxx)  //必须是某一类型组成的数组
 PropTypes.objectOf(PropTypes.xxx)  //对象由某一类型的值组成
 PropTypes.shape(对象)  //属性必须是对象，并且满足指定的对象要求

 PropTypes.exact({...})  //对象必须精确匹配传递的数据(不能有多余的属性，用法和shape一样)

 属性： function(props,propName,componentName){
    // ...
 }

```


# HOC（Higher-Order Function） 高阶组件

HOF： 高阶函数，以函数作为参数，并返回一个函数

通常，可以利用HOC实现横切关注点

举例： 20个组件，每个组件在创建组件和销毁组件时，需要作日志记录
20个组件，他们需要显示一些内容，得到的数据结构完全一致

**注意**
1. 不要在render里面使用高阶函数
2. 不要在高阶组件内部更改传入的组件


# ref: 引用
场景： 希望直接使用dom元素中的某个方法，或者希望直接使用自定义组件中的某个方法

1. ref作用于内置的html组件，得到的将是真实的dom对象
2. ref作用于类组件，得到的将是类的对象
3. ref不能作用于函数组件

ref不在推荐使用字符串赋值，字符串赋值的方式将来可能会被移除
目前ref推荐使用对象或者函数

1. 对象： 通过React.createRef函数创建
在constructor构造函数里面创建，this.txt = React.creatRef(),那么如果要操作dom，就要通过this.txt.current来调用方法

2. 函数：
ref = (el) => this.txt = el, 函数传递一个dom参数，操作dom可以直接使用this.txt调用方法
函数调用时间：
   1. 在componentDidMount钩子函数会调用该函数，在componentDidMount事件中可以使用ref
   2. 如果ref的值发生了变动（旧的函数被新的函数替代），分别调用旧的函数和新的函数，时间点在出现在componentDidUpdate之前，
      旧的函数被调用时，传递的是null，新函数调用时传递的是对象

   3. 如果不希望ref被新的函数替代，可以在在实例上添加函数getRef= el=> this.txt = el,然后在把函数赋值给ref，
      那么这个函数就只会在componentDidMount和componentWillUnmount卸载时调用

**谨慎使用ref**
能够使用属性和状态进行控制，就不要使用ref

1. 调用真实的dom对象中的方法
2. 某个时候需要调用类组件的方法


# ref转发
React.forwardRef方法：传递一个函数组件A，得到一个新的组件newA
1. 参数：函数组件,不能是类组件，并且函数组件需要有第二个参数来获取ref
2. 返回一个新的组件


# context
上下文： context，表示做某些事的环境

特点：
1. 当某个组件创建了上下文后，上下文中的数据，会被所有后代组件共享
2. 如果某个组件依赖了上下文，会导致该组件不再纯粹（数据不仅来源于属性props）
3. 一般情况下，用于第三方组件（通用组件）


# 如何创建上下文？

## 旧的API
只有类组件才可以创建上下文
1. 给类组件书写静态属性 childContextTypes，使用该属性对上下文中的数据类型进行约束
2. 添加实例方法getChildContext，该方法返回的对象，即为上下文中的数据，该数据必须满足约束类型,该方法会在每次render之后运行
```js
 static childContextTypes = {
   a: PropTypes.number,
   b: PropTypes.string
}
getChildContext(){
   return {
      a: 123,
      b: 'sdfd'
   }
}
```
3. 后代使用上下文数据：
要求： 
   1. 如果要使用上下文中的数据，组件必须有一个静态属性contextTypes，该属性描述了需要获取的上下文中的数据类型
      ```js
      static contextTypes = {
         a: PropTypes.number
      }
      ```
   2. 可以在组件的构造函数中，通过第二个参数获取上下文数据
      ```js
      constructor(props,context){}
      ```
   3. **从组件的context属性中获取**
   ```js
   constructor(props,context){
        super(props,context);  // 将上下文交给父类处理
        console.log(this.context);
    }

    this.context.a
   ```
   如果写构造函数的话，需要把上下文参数传递给父类，如果不写构造函数的话，直接从this.context读取上下文数据

   4. 在函数组件中，通过第二个参数获取上下文数据 （创建上下文的只能时类组件，函数组件可以获取）

   **上下文的数据变化**
   上下文的数据不可以直接变化，最终都是通过状态改变
   在上下文中加入一个处理函数，可以用于后代组件更改上下文数据
   ```js
    static childContextTypes = {
        a: PropTypes.number,
        b: PropTypes.string,
        onChange: PropTypes.func
    }
    getChildContext(){
        return {
            a: 123,
            b: 'sdfd',
            onChange: (newA) => {
                this.setState({
                    a: newA
                })
            }
        }
    }
   ```

## 新版API
旧版API 存在严重的效率问题，并且容易导致滥用

**创建上下文**

上下文是一个独立于组件的对象,该对象通过React.createContext(默认值)创建
返回的是一个包含两个属性的对象：
1. Provider属性：生产者，一个组件，该组件会创建一个上下文，该组件有一个value属性，通过该属性，可以为其数据赋值,
同一个Provider不要用到多个组件中，如果需要在其他组件中使用该数据，应该考虑将数据提升到更高的层次

2. Consumers属性：

**使用上下文的数据**

在类组件中，直接使用this.context获取上下文数据
要求： 必须拥有静态属性contextType，应赋值为创建的上下文对象

在函数组件中，需要使用Consumer来获取上下文数据, Consumer在类组件中也可以使用
1. Consumer是一个组件
2. 它的子节点是一个函数（它的props.children需要传递一个函数）

**细节**
如果，上下文提供者（Context、Provider）中的value属性发生变化（Object.is来比较），会导致该上下文提供的所有后代元素全部更新，
无论该子元素是否有优化（shouldComponentUpdate函数返回什么结果），会强制更新。

# 上下文的应用场景
编写一套组件（有多个组件），这些组件之间需要相互配合才能最终完成功能
比如： 开发一套表单组件，使用方式如下：
```js
render() {
   return (
      <Form onSubmit={datas => {
         console.log(datas)
      }}>
         <div>
            账号：<Form.Input name="loginId">
         </div>
         <div>
            密码：<Form.Input name="loginPwd" type="password">
         </div>
         <div>
            <Form.Button>提交</Form.Button>
         </div>
      </Form>
   )
}
```


# PureComponent
纯组件，用于避免不必要的渲染（运行render函数），从而提高效率

优化： 如果一个组件的属性和状态，都没有发生改变，重新渲染该组件是没有必要的

PureComponent是一个组件，如果某个组件继承自该组件，则该组件的shouldComponentUpdate会进行优化，对属性和状态进行浅比较

**注意**

1. PureComponent进行是浅比较
   1. 为了效率，应该尽量使用PureComponent
   2. 要求不要改动之前的状态，永远是创建新的状态覆盖之前的状态（Immutable，不可变对象）
   3. 有一个第三方js库，Immutable.js，专门用于制作不可变对象

2. 函数组件，使用React.memo函数制作纯函数, export default React.memo(Task);